<!DOCTYPE html>
<html lang="zh_CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Linux , PHP, Pyhton, MySql, Shell, Ruby Development Note.">
    <meta name="author" content="pochonlee@gmail.com">
    <title>OutMan / God help those who help themselves.</title>
    <link href="/static/bootstrap/css/bootstrap.min.css?v=0.1" rel="stylesheet">
    <link href="/static/css/main.css?v=0.1" rel="stylesheet" >
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">OutMan / God help those who help themselves.</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
                <li class="active"><a href="/">Home</a></li>
                <li><a href="about.html">About</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div>
</nav>

<div class="container">
    <h3>php 静态绑定</h3>
<p>下面是 ZendFramework2 中的一段代码</p>
<p>```php
/<em><em>
 * Constructor.
 </em>
 * Data is read-only unless $allowModifications is set to true
 * on construction.
 </em>
 * @param  array   $array
 * @param  bool $allowModifications
 */
public function __construct(array $array, $allowModifications = false)
{
    $this-&gt;allowModifications = (bool) $allowModifications;</p>
<pre><code>foreach ($array as $key =&gt; $value) {
    if (is_array($value)) {

        // 看这部分 new static
        $this-&gt;data[$key] = new static($value, $this-&gt;allowModifications);
    } else {
        $this-&gt;data[$key] = $value;
    }

    $this-&gt;count++;
}
</code></pre>
<p>}
<code>下面一段是 php 官方的文档解释</code>
自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。
准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。</p>
<p>该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。
```</p>
<p>具体看几个例子，来加深对这部分内容的理解，例子来自 <a href="http://stackoverflow.com/questions/5197300/new-self-vs-new-static" title="stackoverflow">stackoverflow</a></p>
<p>```php
class A {
    public static function get_self() {
        return new self();
    }
    public static function get_static() {
        return new static();
    }
}</p>
<p>class B extends A {}</p>
<p>echo get_class(B::get_self());  // A
echo get_class(B::get_static()); // B
echo get_class(A::get_static()); // A
```</p>
<p>下面的例子是来自 <a href="http://php.net/manual/zh/language.oop5.late-static-bindings.php">php</a> 手册
```php
&lt;?php
class A {
    public static function who() {
        echo <strong>CLASS</strong>;
    }
    public static function test() {
        self::who();
    }
}</p>
<p>class B extends A {
    public static function who() {
        echo <strong>CLASS</strong>;
    }
}</p>
<p>B::test(); // A
?&gt;</p>
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // 后期静态绑定从这里开始
    }
}

<p>class B extends A {
    public static function who() {
        echo <strong>CLASS</strong>;
    }
}</p>
<p>B::test(); // B
?&gt;
```</p>
<p><code>Note:
在非静态环境下，所调用的类即为该对象实例所属的类。由于 $this-&gt; 会在同一作用范围内尝试调用私有方法，而 static:: 则可能给出不同结果。另一个区别是 static:: 只能用于静态属性。</code></p>
<p>看下下面这段代码，5.2和5.3的比较，就知道了
```
class A {
    public function create1() {
        $class = get_class($this);
        return new $class();
    }
    public function create2() {
        return new static();
    }
}</p>
<p>class B extends A {</p>
<p>}</p>
<p>$b = new B();
var_dump(get_class($b-&gt;create1()), get_class($b-&gt;create2())); // B,B
```</p>
</div>
<script src="/static/js/jquery.min.js?v=0.1"></script>
<script src="/static/bootstrap/js/bootstrap.min.js?v=0.1"></script>
</body>
</html>